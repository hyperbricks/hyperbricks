<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hyperbricks Deploy Dashboard</title>
    <script>
      (function () {
        try {
          var stored = localStorage.getItem("hb-theme");
          var prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
          var theme = stored || (prefersLight ? "light" : "dark");
          document.documentElement.setAttribute("data-theme", theme);
        } catch (e) {}
      })();
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/dashboard.css">
  </head>
  <body data-mode="remote">
    <div class="shell">
      <header class="hero">
        <div class="hero-bar">
          <div class="badge">Deploy | Remote</div>
          <div class="hero-actions">
            <button id="themeToggle" class="icon-toggle theme-toggle" type="button" aria-pressed="true" aria-label="Toggle theme">
              <svg class="theme-icon theme-icon-dark" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M20 14.5A8 8 0 0 1 9.5 4a7 7 0 1 0 10.5 10.5z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              </svg>
              <svg class="theme-icon theme-icon-light hidden" viewBox="0 0 24 24" aria-hidden="true">
                <circle cx="12" cy="12" r="4" fill="none" stroke="currentColor" stroke-width="2"/>
                <path d="M12 2v3M12 19v3M4.2 4.2l2.1 2.1M17.7 17.7l2.1 2.1M2 12h3M19 12h3M4.2 19.8l2.1-2.1M17.7 6.3l2.1-2.1" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              </svg>
            </button>
            <div class="menu">
              <button id="menuToggle" class="ghost" type="button">Settings</button>
              <div id="menuPanel" class="menu-panel hidden">
                <div class="menu-section remote-only">
                  <div class="menu-title">Connection</div>
                  <div class="connect menu-connect">
                    <div class="connect-row">
                      <div class="field">
                        <label for="baseUrl">API Base</label>
                        <input id="baseUrl" placeholder="http://127.0.0.1:9090" />
                      </div>
                      <div class="field">
                        <label for="secret">HMAC Secret</label>
                        <input id="secret" type="password" placeholder="Enter shared secret" />
                      </div>
                    </div>
                    <div class="actions-row">
                      <button id="loadModules">Load Modules</button>
                      <button id="refreshStatus" class="secondary" disabled>Refresh Status</button>
                      <button id="clearSecret" class="ghost" type="button">Clear Secret</button>
                    </div>
                    <div class="note-row">
                      <span class="note">Timestamp and nonce are generated per request.</span>
                      <span id="signerMode" class="note"></span>
                    </div>
                  </div>
                </div>
                <div class="menu-section local-only">
                  <div class="menu-title">Connection</div>
                  <div class="connect menu-connect">
                    <div class="connect-row">
                      <div class="field">
                        <label for="localApiBase">Local API</label>
                        <input id="localApiBase" readonly />
                      </div>
                      <div class="field">
                        <label for="localTargetName">Target</label>
                        <input id="localTargetName" readonly />
                      </div>
                    </div>
                    <div class="connect-row">
                      <div class="field">
                        <label for="localTargetApi">Remote API</label>
                        <input id="localTargetApi" readonly />
                      </div>
                      <div class="field">
                        <label for="localTargetRoot">Remote Root</label>
                        <input id="localTargetRoot" readonly />
                      </div>
                    </div>
                    <div class="note-row">
                      <span class="note">Local mode uses deploy.client for push/sync.</span>
                    </div>
                  </div>
                </div>
                <div class="menu-divider"></div>
                <button id="killAllProcesses" class="danger menu-action remote-only" type="button">Kill all hyperbricks (except API)</button>
              </div>
            </div>
          </div>
        </div>
        <div class="hero-brand">
          <img class="hero-logo" src="/assets/logo_blue.png" alt="Hyperbricks logo" data-logo-dark="/assets/logo_blue.png" data-logo-light="/assets/logo_black.png" />
          <div class="hero-text">
            <p>Client for deploy management.</p>
          </div>
        </div>
      </header>

      <div class="view-toggle">
        <button id="viewModules" class="toggle active" type="button">Modules</button>
        <button id="viewPlugins" class="toggle ghost" type="button">Plugins</button>
      </div>

      <div id="modulesView" class="grid">
        <section class="panel status">
          <h2>Server Status</h2>
          <div class="status-grid">
            <div class="status-card">
              <span>API</span>
              <strong id="apiStatus">offline</strong>
            </div>
            <div class="status-card">
              <span>Last Check</span>
              <strong id="apiTime">-</strong>
            </div>
            <div class="status-card">
              <span>Hyperbricks</span>
              <strong id="apiVersion">-</strong>
            </div>
          </div>
        </section>

        <section class="panel modules">
          <h2>Modules</h2>
          <ul id="moduleList" class="module-list"></ul>
        </section>

        <section class="panel builds">
          <div class="panel-header">
            <h2>Builds</h2>
            <div class="actions-row">
              <button id="buildModule" class="secondary local-only" type="button">Build</button>
              <button id="syncRemote" class="ghost local-only" type="button">Sync Remote</button>
              <button id="rollbackModule" class="danger remote-only" disabled>Rollback</button>
              <span id="rollbackTarget" class="note remote-only">-</span>
            </div>
          </div>
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th>Build</th>
                  <th>Version</th>
                  <th>Built</th>
                  <th>Mode</th>
                  <th>Status</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="buildRows">
                <tr>
                  <td colspan="6" class="note">Select a module to load builds.</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>

        <section class="panel log">
          <h2>Activity</h2>
          <pre id="activity">Ready.</pre>
        </section>
      </div>

      <div id="pluginsView" class="grid hidden">
        <section class="panel status">
          <h2>Server Status</h2>
          <div class="status-grid">
            <div class="status-card">
              <span>API</span>
              <strong id="apiStatusPlugins">offline</strong>
            </div>
            <div class="status-card">
              <span>Last Check</span>
              <strong id="apiTimePlugins">-</strong>
            </div>
            <div class="status-card">
              <span>Hyperbricks</span>
              <strong id="apiVersionPlugins">-</strong>
            </div>
          </div>
        </section>
        <section class="panel plugins-global">
          <div class="panel-header">
            <h2>Global Plugins</h2>
            <div class="actions-row">
              <button id="refreshGlobalPlugins" class="secondary" type="button">Refresh</button>
            </div>
          </div>
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th>Plugin</th>
                  <th>Version</th>
                  <th>Status</th>
                  <th>Config</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="globalPluginRows">
                <tr>
                  <td colspan="5" class="note">Load plugins to see the global index.</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>

        <section class="panel plugins-custom">
          <div class="panel-header">
            <h2>Custom Plugins</h2>
            <div class="actions-row">
              <div class="field">
                <label for="pluginModule">Module</label>
                <select id="pluginModule"></select>
              </div>
              <div class="field remote-only">
                <label for="pluginBuild">Build</label>
                <select id="pluginBuild"></select>
              </div>
              <button id="loadCustomPlugins" class="secondary" type="button">Load</button>
            </div>
          </div>
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th>Plugin</th>
                  <th>Version</th>
                  <th>Status</th>
                  <th>Config</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="customPluginRows">
                <tr>
                  <td colspan="5" class="note">Select a module to load custom plugins.</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>

        <section class="panel log">
          <h2>Activity</h2>
          <pre id="pluginActivity">Ready.</pre>
        </section>
      </div>
    </div>

    <script>
      const ui = {
        baseUrl: document.getElementById("baseUrl"),
        secret: document.getElementById("secret"),
        localApiBase: document.getElementById("localApiBase"),
        localTargetName: document.getElementById("localTargetName"),
        localTargetApi: document.getElementById("localTargetApi"),
        localTargetRoot: document.getElementById("localTargetRoot"),
        moduleList: document.getElementById("moduleList"),
        buildRows: document.getElementById("buildRows"),
        apiStatus: document.getElementById("apiStatus"),
        apiTime: document.getElementById("apiTime"),
        apiVersion: document.getElementById("apiVersion"),
        apiStatusPlugins: document.getElementById("apiStatusPlugins"),
        apiTimePlugins: document.getElementById("apiTimePlugins"),
        apiVersionPlugins: document.getElementById("apiVersionPlugins"),
        signerMode: document.getElementById("signerMode"),
        loadModules: document.getElementById("loadModules"),
        refreshStatus: document.getElementById("refreshStatus"),
        clearSecret: document.getElementById("clearSecret"),
        buildModule: document.getElementById("buildModule"),
        syncRemote: document.getElementById("syncRemote"),
        rollbackModule: document.getElementById("rollbackModule"),
        rollbackTarget: document.getElementById("rollbackTarget"),
        activity: document.getElementById("activity"),
        pluginActivity: document.getElementById("pluginActivity"),
        menuToggle: document.getElementById("menuToggle"),
        menuPanel: document.getElementById("menuPanel"),
        killAll: document.getElementById("killAllProcesses"),
        modulesView: document.getElementById("modulesView"),
        pluginsView: document.getElementById("pluginsView"),
        viewModules: document.getElementById("viewModules"),
        viewPlugins: document.getElementById("viewPlugins"),
        globalPluginRows: document.getElementById("globalPluginRows"),
        refreshGlobalPlugins: document.getElementById("refreshGlobalPlugins"),
        customPluginRows: document.getElementById("customPluginRows"),
        pluginModule: document.getElementById("pluginModule"),
        pluginBuild: document.getElementById("pluginBuild"),
        loadCustomPlugins: document.getElementById("loadCustomPlugins")
      };

      const mode = (document.body.dataset.mode || "remote").toLowerCase();
      const isLocalMode = mode === "local";

      const state = {
        mode: mode,
        modules: [],
        selectedModule: "",
        builds: [],
        runningBuild: "",
        currentBuild: "",
        selectionToken: 0,
        logsEnabled: !isLocalMode,
        view: "modules",
        pluginModule: "",
        pluginBuild: "",
        buildCounts: {}
      };
      document.body.classList.add(isLocalMode ? "mode-local" : "mode-remote");

      const storageKeys = {
        secret: "hbDeploySecret",
        module: "hbDeployModule",
        view: "hbDeployView"
      };

      const icons = {
        more: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="5" r="2" fill="currentColor"></circle>
          <circle cx="12" cy="12" r="2" fill="currentColor"></circle>
          <circle cx="12" cy="19" r="2" fill="currentColor"></circle>
        </svg>`,
        install: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 5v14M5 12h14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>`,
        rebuild: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M4 12a8 8 0 0 1 14.5-4.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M18 4v5h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>`,
        compile: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M13 2L3 14h7l-1 8 10-12h-7l1-8z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"></path>
        </svg>`,
        remove: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M4 7h16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M9 7V5h6v2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <rect x="6" y="7" width="12" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
          <path d="M10 11v6M14 11v6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>`,
        start: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7 5l12 7-12 7z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"></path>
        </svg>`,
        restart: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M4 12a8 8 0 0 1 14.5-4.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M18 4v5h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
          <path d="M20 12a8 8 0 0 1-14.5 4.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M6 20v-5h5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>`,
        stop: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="6" y="6" width="12" height="12" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
        </svg>`,
        link: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M10 13a5 5 0 0 1 0-7l2-2a5 5 0 0 1 7 7l-1 1" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M14 11a5 5 0 0 1 0 7l-2 2a5 5 0 0 1-7-7l1-1" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>`,
        dashboard: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="3" y="3" width="8" height="8" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
          <rect x="13" y="3" width="8" height="8" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
          <rect x="3" y="13" width="8" height="8" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
          <rect x="13" y="13" width="8" height="8" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
        </svg>`,
        details: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2"></circle>
          <path d="M12 10v6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <circle cx="12" cy="7" r="1" fill="currentColor"></circle>
        </svg>`,
        delete: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M4 7h16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M9 7V5h6v2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <rect x="6" y="7" width="12" height="13" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect>
          <path d="M10 11v6M14 11v6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
        </svg>`,
        push: `<svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 19V5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path>
          <path d="M6 11l6-6 6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>`
      };

      let rowMenuCounter = 0;

      let serverStatusTimer = null;

      function setActivity(message, isError) {
        const color = isError ? "var(--danger)" : "var(--ink)";
        const targets = [ui.activity, ui.pluginActivity].filter(Boolean);
        targets.forEach((target) => {
          target.textContent = message;
          target.style.color = color;
        });
      }

      function isSelectionCurrent(token, module) {
        return token === state.selectionToken && module === state.selectedModule;
      }

      function shortenValue(value) {
        if (!value) {
          return "-";
        }
        const text = String(value);
        if (text.length <= 12) {
          return text;
        }
        return text.slice(0, 5) + "â€¦" + text.slice(-5);
      }

      function formatDate(value) {
        if (!value) {
          return "-";
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return value;
        }
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        let hours = date.getHours();
        const minutes = String(date.getMinutes()).padStart(2, "0");
        const ampm = hours >= 12 ? "PM" : "AM";
        hours = hours % 12;
        if (hours === 0) {
          hours = 12;
        }
        const hourStr = String(hours).padStart(2, "0");
        return year + "-" + month + "-" + day + ", " + hourStr + ":" + minutes + " " + ampm;
      }

      function formatRelativeTime(value) {
        if (!value) {
          return "-";
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return value;
        }
        const diffMs = Date.now() - date.getTime();
        const absMs = Math.abs(diffMs);
        if (absMs < 60000) {
          return "just now";
        }
        const units = [
          { label: "y", ms: 31536000000 },
          { label: "mo", ms: 2592000000 },
          { label: "w", ms: 604800000 },
          { label: "d", ms: 86400000 },
          { label: "h", ms: 3600000 },
          { label: "m", ms: 60000 }
        ];
        for (const unit of units) {
          const amount = Math.floor(absMs / unit.ms);
          if (amount >= 1) {
            return diffMs >= 0 ? amount + unit.label + " ago" : "in " + amount + unit.label;
          }
        }
        return "just now";
      }

      function buildTimestamp(value) {
        if (!value) {
          return 0;
        }
        const date = new Date(value);
        const time = date.getTime();
        return Number.isNaN(time) ? 0 : time;
      }

      function copyText(value) {
        if (!value || value === "-") {
          return Promise.resolve();
        }
        if (navigator.clipboard && window.isSecureContext) {
          return navigator.clipboard.writeText(value);
        }
        const textarea = document.createElement("textarea");
        textarea.value = value;
        textarea.style.position = "fixed";
        textarea.style.opacity = "0";
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand("copy");
        } catch (err) {
          return Promise.reject(err);
        } finally {
          document.body.removeChild(textarea);
        }
        return Promise.resolve();
      }

      function getBaseUrl() {
        const raw = ui.baseUrl.value.trim();
        if (raw) {
          return raw;
        }
        if (window.location.origin && window.location.origin !== "null") {
          return window.location.origin;
        }
        return "http://127.0.0.1:9090";
      }

      function getApiPrefix() {
        return isLocalMode ? "/local" : "/deploy";
      }

      function apiPath(path) {
        return getApiPrefix() + path;
      }

      function getSecret() {
        return ui.secret.value.trim();
      }

      function getSavedModule() {
        return localStorage.getItem(storageKeys.module) || "";
      }

      function saveModule(module) {
        if (module) {
          localStorage.setItem(storageKeys.module, module);
        }
      }

      function toHex(buffer) {
        return Array.from(new Uint8Array(buffer))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }

      function hasWebCrypto() {
        return !!(window.crypto && window.crypto.subtle && window.isSecureContext);
      }

      function utf8Bytes(str) {
        if (window.TextEncoder) {
          return new TextEncoder().encode(str);
        }
        const out = [];
        for (let i = 0; i < str.length; i++) {
          let code = str.charCodeAt(i);
          if (code < 0x80) {
            out.push(code);
          } else if (code < 0x800) {
            out.push(0xc0 | (code >> 6), 0x80 | (code & 0x3f));
          } else if (code < 0xd800 || code >= 0xe000) {
            out.push(
              0xe0 | (code >> 12),
              0x80 | ((code >> 6) & 0x3f),
              0x80 | (code & 0x3f)
            );
          } else {
            i++;
            const next = str.charCodeAt(i);
            const u = ((code & 0x3ff) << 10) | (next & 0x3ff) | 0x10000;
            out.push(
              0xf0 | (u >> 18),
              0x80 | ((u >> 12) & 0x3f),
              0x80 | ((u >> 6) & 0x3f),
              0x80 | (u & 0x3f)
            );
          }
        }
        return new Uint8Array(out);
      }

      function concatBytes(a, b) {
        const out = new Uint8Array(a.length + b.length);
        out.set(a, 0);
        out.set(b, a.length);
        return out;
      }

      function sha256Bytes(bytes) {
        const K = [
          0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
          0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
          0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
          0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
          0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
          0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
          0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
          0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
          0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
          0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
          0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
          0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
          0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
          0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
        ];

        let h0 = 0x6a09e667;
        let h1 = 0xbb67ae85;
        let h2 = 0x3c6ef372;
        let h3 = 0xa54ff53a;
        let h4 = 0x510e527f;
        let h5 = 0x9b05688c;
        let h6 = 0x1f83d9ab;
        let h7 = 0x5be0cd19;

        const bitLenHi = Math.floor(bytes.length / 0x20000000);
        const bitLenLo = (bytes.length << 3) >>> 0;
        const withOne = bytes.length + 1;
        const padLen = (64 - ((withOne + 8) % 64)) % 64;
        const total = bytes.length + 1 + padLen + 8;
        const data = new Uint8Array(total);
        data.set(bytes, 0);
        data[bytes.length] = 0x80;
        data[total - 8] = (bitLenHi >>> 24) & 0xff;
        data[total - 7] = (bitLenHi >>> 16) & 0xff;
        data[total - 6] = (bitLenHi >>> 8) & 0xff;
        data[total - 5] = bitLenHi & 0xff;
        data[total - 4] = (bitLenLo >>> 24) & 0xff;
        data[total - 3] = (bitLenLo >>> 16) & 0xff;
        data[total - 2] = (bitLenLo >>> 8) & 0xff;
        data[total - 1] = bitLenLo & 0xff;

        const w = new Array(64);
        for (let offset = 0; offset < data.length; offset += 64) {
          for (let i = 0; i < 16; i++) {
            const j = offset + i * 4;
            w[i] = ((data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | data[j + 3]) >>> 0;
          }
          for (let i = 16; i < 64; i++) {
            const v1 = w[i - 2];
            const s1 = ((v1 >>> 17) | (v1 << 15)) ^ ((v1 >>> 19) | (v1 << 13)) ^ (v1 >>> 10);
            const v2 = w[i - 15];
            const s0 = ((v2 >>> 7) | (v2 << 25)) ^ ((v2 >>> 18) | (v2 << 14)) ^ (v2 >>> 3);
            w[i] = (w[i - 16] + s0 + w[i - 7] + s1) >>> 0;
          }

          let a = h0;
          let b = h1;
          let c = h2;
          let d = h3;
          let e = h4;
          let f = h5;
          let g = h6;
          let h = h7;

          for (let i = 0; i < 64; i++) {
            const S1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
            const ch = (e & f) ^ (~e & g);
            const temp1 = (h + S1 + ch + K[i] + w[i]) >>> 0;
            const S0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
            const maj = (a & b) ^ (a & c) ^ (b & c);
            const temp2 = (S0 + maj) >>> 0;

            h = g;
            g = f;
            f = e;
            e = (d + temp1) >>> 0;
            d = c;
            c = b;
            b = a;
            a = (temp1 + temp2) >>> 0;
          }

          h0 = (h0 + a) >>> 0;
          h1 = (h1 + b) >>> 0;
          h2 = (h2 + c) >>> 0;
          h3 = (h3 + d) >>> 0;
          h4 = (h4 + e) >>> 0;
          h5 = (h5 + f) >>> 0;
          h6 = (h6 + g) >>> 0;
          h7 = (h7 + h) >>> 0;
        }

        const out = new Uint8Array(32);
        const hs = [h0, h1, h2, h3, h4, h5, h6, h7];
        for (let i = 0; i < hs.length; i++) {
          const v = hs[i];
          out[i * 4] = (v >>> 24) & 0xff;
          out[i * 4 + 1] = (v >>> 16) & 0xff;
          out[i * 4 + 2] = (v >>> 8) & 0xff;
          out[i * 4 + 3] = v & 0xff;
        }
        return out;
      }

      function hmacSha256Bytes(keyBytes, msgBytes) {
        const blockSize = 64;
        let key = keyBytes;
        if (key.length > blockSize) {
          key = sha256Bytes(key);
        }
        if (key.length < blockSize) {
          const padded = new Uint8Array(blockSize);
          padded.set(key, 0);
          key = padded;
        }
        const oKey = new Uint8Array(blockSize);
        const iKey = new Uint8Array(blockSize);
        for (let i = 0; i < blockSize; i++) {
          const b = key[i];
          oKey[i] = b ^ 0x5c;
          iKey[i] = b ^ 0x36;
        }
        const inner = sha256Bytes(concatBytes(iKey, msgBytes));
        return sha256Bytes(concatBytes(oKey, inner));
      }

      function sha256HexFallback(text) {
        const bytes = utf8Bytes(text);
        const hashBytes = sha256Bytes(bytes);
        return toHex(hashBytes);
      }

      function hmacHexFallback(key, text) {
        const keyBytes = utf8Bytes(key);
        const msgBytes = utf8Bytes(text);
        const out = hmacSha256Bytes(keyBytes, msgBytes);
        return toHex(out);
      }

      async function sha256Hex(text) {
        if (hasWebCrypto()) {
          try {
            const data = utf8Bytes(text);
            const hash = await crypto.subtle.digest("SHA-256", data);
            return toHex(hash);
          } catch (err) {
            return sha256HexFallback(text);
          }
        }
        return sha256HexFallback(text);
      }

      async function hmacHex(key, text) {
        if (hasWebCrypto()) {
          try {
            const keyData = utf8Bytes(key);
            const cryptoKey = await crypto.subtle.importKey(
              "raw",
              keyData,
              { name: "HMAC", hash: "SHA-256" },
              false,
              ["sign"]
            );
            const sig = await crypto.subtle.sign(
              "HMAC",
              cryptoKey,
              utf8Bytes(text)
            );
            return toHex(sig);
          } catch (err) {
            return hmacHexFallback(key, text);
          }
        }
        return hmacHexFallback(key, text);
      }

      function randomHex(length) {
        const bytes = new Uint8Array(length / 2);
        if (window.crypto && crypto.getRandomValues) {
          crypto.getRandomValues(bytes);
        } else {
          for (let i = 0; i < bytes.length; i++) {
            bytes[i] = Math.floor(Math.random() * 256);
          }
        }
        return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
      }

      function setApiStatus(stateText) {
        const timeText = new Date().toLocaleTimeString();
        if (ui.apiStatus) {
          ui.apiStatus.textContent = stateText;
        }
        if (ui.apiTime) {
          ui.apiTime.textContent = timeText;
        }
        if (ui.apiStatusPlugins) {
          ui.apiStatusPlugins.textContent = stateText;
        }
        if (ui.apiTimePlugins) {
          ui.apiTimePlugins.textContent = timeText;
        }
      }

      function findRollbackTarget(builds, currentBuild) {
        if (!currentBuild || !Array.isArray(builds)) {
          return "";
        }
        for (let i = builds.length - 1; i >= 0; i--) {
          const buildId = builds[i].build_id;
          if (buildId && buildId !== currentBuild) {
            return buildId;
          }
        }
        return "";
      }

      function updateRollbackTarget() {
        if (!ui.rollbackTarget || !ui.rollbackModule) {
          return;
        }
        if (isLocalMode) {
          ui.rollbackTarget.textContent = "-";
          ui.rollbackTarget.removeAttribute("title");
          ui.rollbackModule.disabled = true;
          return;
        }
        if (!state.selectedModule) {
          ui.rollbackTarget.textContent = "-";
          ui.rollbackTarget.removeAttribute("title");
          ui.rollbackModule.disabled = true;
          return;
        }
        const target = findRollbackTarget(state.builds, state.currentBuild);
        if (!target) {
          ui.rollbackTarget.textContent = "No previous build";
          ui.rollbackTarget.removeAttribute("title");
          ui.rollbackModule.disabled = true;
          return;
        }
        ui.rollbackTarget.textContent = "Rolls back to " + shortenValue(target);
        ui.rollbackTarget.title = target;
        ui.rollbackModule.disabled = false;
      }

      function escapeAttr(value) {
        return String(value)
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function renderRowMenu(items) {
        const menuId = "rowMenu-" + (rowMenuCounter += 1);
        const menuItems = (items || []).map((item) => {
          const classes = ["row-menu-item", item.className || ""].filter(Boolean).join(" ");
          const attrs = item.attrs || "";
          const disabledAttr = item.disabled ? " disabled" : "";
          const icon = item.icon || "";
          const label = item.label || "";
          return `<button class="${classes}"${attrs} data-action="${item.action}"${disabledAttr} type="button">${icon}<span>${label}</span></button>`;
        }).join("");
        return `
          <div class="row-menu">
            <button class="row-menu-toggle icon-toggle" data-menu="${menuId}" type="button" aria-expanded="false" aria-haspopup="menu" aria-label="Row actions">
              ${icons.more}
            </button>
            <div id="${menuId}" class="row-menu-panel hidden">
              ${menuItems}
            </div>
          </div>
        `;
      }

      function ensureRowMenuPortal() {
        let portal = document.getElementById("rowMenuPortal");
        if (!portal) {
          portal = document.createElement("div");
          portal.id = "rowMenuPortal";
          document.body.appendChild(portal);
        }
        return portal;
      }

      function closeRowMenus() {
        document.querySelectorAll(".row-menu-panel").forEach((panel) => {
          panel.classList.add("hidden");
          panel.classList.remove("is-floating");
          panel.style.top = "";
          panel.style.left = "";
          panel.style.visibility = "";
          if (panel._rowMenuParent) {
            panel._rowMenuParent.appendChild(panel);
            panel._rowMenuParent = null;
          }
        });
        document.querySelectorAll(".row-menu-toggle").forEach((button) => {
          button.setAttribute("aria-expanded", "false");
        });
      }

      function openRowMenu(panel, button) {
        if (!panel || !button) {
          return;
        }
        closeRowMenus();
        const portal = ensureRowMenuPortal();
        if (!panel._rowMenuParent) {
          panel._rowMenuParent = panel.parentElement;
        }
        portal.appendChild(panel);
        panel.classList.remove("hidden");
        panel.classList.add("is-floating");
        panel.style.visibility = "hidden";
        panel.style.left = "0px";
        panel.style.top = "0px";
        const toggleRect = button.getBoundingClientRect();
        const panelRect = panel.getBoundingClientRect();
        let top = toggleRect.bottom + 6;
        if (top + panelRect.height > window.innerHeight - 8) {
          top = Math.max(8, toggleRect.top - panelRect.height - 6);
        }
        let left = toggleRect.right - panelRect.width;
        if (left < 8) {
          left = 8;
        }
        if (left + panelRect.width > window.innerWidth - 8) {
          left = Math.max(8, window.innerWidth - panelRect.width - 8);
        }
        panel.style.top = top + "px";
        panel.style.left = left + "px";
        panel.style.visibility = "visible";
        button.setAttribute("aria-expanded", "true");
      }

      function wireRowMenus(container) {
        if (!container) {
          return;
        }
        container.querySelectorAll(".row-menu-toggle").forEach((button) => {
          button.addEventListener("click", (event) => {
            event.stopPropagation();
            const menuId = button.dataset.menu || "";
            const panel = menuId ? document.getElementById(menuId) : null;
            if (!panel) {
              return;
            }
            const isOpen = !panel.classList.contains("hidden");
            if (isOpen) {
              closeRowMenus();
              return;
            }
            openRowMenu(panel, button);
          });
        });
        container.querySelectorAll(".row-menu-panel").forEach((panel) => {
          panel.addEventListener("click", (event) => event.stopPropagation());
        });
      }

      function metaValue(value, options) {
        const opts = options || {};
        const raw = value ? String(value) : "";
        const display = raw ? (opts.shorten ? shortenValue(raw) : raw) : "-";
        const titleText = opts.title ? String(opts.title) : (raw && display !== raw ? raw : "");
        const className = opts.mono ? "mono wrap" : "";
        const titleAttr = titleText ? ` title="${escapeAttr(titleText)}"` : "";
        const classAttr = className ? ` class="${className}"` : "";
        return `<strong${classAttr}${titleAttr}>${display}</strong>`;
      }

      function metaRow(label, valueHtml) {
        return `<div class="meta-row"><span>${label}</span>${valueHtml}</div>`;
      }

      function metaLink(label, url) {
        if (!url) {
          return metaRow(label, "<strong>-</strong>");
        }
        const safeUrl = escapeAttr(url);
        return metaRow(
          label,
          `<a class="link" href="${safeUrl}" target="_blank" rel="noreferrer">${url}</a>`
        );
      }

      function stripAnsi(text) {
        if (!text) {
          return "";
        }
        return String(text).replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, "");
      }

      function buildDetailsHTML(module, buildId, data) {
        const localMode = isLocalMode;
        const running = !!data.running;
        const portValue = data.port || "";
        const portText = portValue ? String(portValue) : "-";
        const moduleName = data.module || module || "-";
        const buildValue = data.build_id || buildId || "-";
        const buildShort = shortenValue(buildValue);
        const buildTitle = buildValue && buildShort !== buildValue ? ` title="${escapeAttr(buildValue)}"` : "";
        const stateText = running ? "running" : "stopped";
        const link = running && portValue ? moduleLinkFromPort(portValue) : "";
        const dash = link ? link + "/dashboard" : "";
        const builtRaw = data.built_at || "";
        const builtDisplay = builtRaw ? formatDate(builtRaw) : "-";
        const logsEnabled = state.logsEnabled !== false;
        const logPanel = logsEnabled
          ? `
            <div class="log-panel" data-log-build="${buildValue}">
              <div class="log-header">
                <span>Logs (tail)</span>
                <div class="log-actions">
                  <button class="ghost log-btn" data-log-action="load" data-build="${buildValue}" type="button">Load</button>
                  <button class="ghost log-btn" data-log-action="refresh" data-build="${buildValue}" type="button">Refresh</button>
                </div>
              </div>
              <pre class="log-output" data-log-output="${buildValue}">Logs not loaded.</pre>
              <span class="note log-note hidden">Log output truncated.</span>
            </div>
          `
          : `<span class="note">Logs disabled in deploy config.</span>`;
        const linkMeta = `
              ${metaLink("Module Link", link)}
              ${metaLink("Module Dashboard", dash)}
            `;
        const remoteMeta = localMode
          ? `
              ${linkMeta}
              ${metaRow("Pushed At", metaValue(data.pushed_at || "-"))}
              ${metaRow("Remote Target", metaValue(data.remote_target || "-"))}
              ${metaRow("Remote Status", metaValue(data.remote_status || (data.pushed_at ? "unknown" : "local")))}
              ${metaRow("Remote Checked", metaValue(data.remote_checked_at || "-"))}
            `
          : linkMeta;
        return `
          <div class="details-shell">
            <div class="status-grid details-grid">
              <div class="status-card">
                <span>State</span>
                <strong>${stateText}</strong>
              </div>
              <div class="status-card">
                <span>Module</span>
                <strong>${moduleName}</strong>
              </div>
              <div class="status-card">
                <span>Build</span>
                <strong class="mono wrap"${buildTitle}>${buildShort}</strong>
              </div>
              <div class="status-card">
                <span>Port</span>
                <strong>${portText}</strong>
              </div>
            </div>
            <div class="meta-scroll">
              ${metaRow("Mode", metaValue(data.production ? "production" : "default"))}
              ${metaRow("Module Version", metaValue(data.moduleversion || "-"))}
              ${metaRow("Commit", metaValue(data.commit || "-", { mono: true, shorten: true }))}
              ${metaRow("Built", metaValue(builtDisplay, { title: builtRaw }))}
              ${metaRow("Source", metaValue(data.source_hash || "-", { mono: true, shorten: true }))}
              ${metaRow("Format", metaValue(data.format || "-"))}
              ${remoteMeta}
            </div>
            ${logPanel}
          </div>
        `;
      }

      async function loadBuildDetails(buildId, detailsRow) {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module || !detailsRow) {
          return;
        }
        const container = detailsRow.querySelector(".build-details");
        if (!container) {
          return;
        }
        container.innerHTML = "<span class=\"note\">Loading status...</span>";
        try {
          const data = await apiRequest("GET", apiPath("/modules/" + module + "/builds/" + buildId + "/status"));
          if (!isSelectionCurrent(token, module)) {
            return;
          }
          container.innerHTML = buildDetailsHTML(module, buildId, data);
          if (state.logsEnabled !== false) {
            wireBuildLogs(container, buildId, data.running);
          }
        } catch (err) {
          if (!isSelectionCurrent(token, module)) {
            return;
          }
          container.innerHTML = "<span class=\"note\">Failed to load build status.</span>";
          handleError(err);
        }
      }

      function toggleBuildDetails(buildId, detailsRow, button) {
        if (!detailsRow || !button) {
          return;
        }
        const isHidden = detailsRow.classList.contains("hidden");
        if (isHidden) {
          detailsRow.classList.remove("hidden");
          button.classList.add("active");
          button.setAttribute("title", "Hide details");
          button.setAttribute("aria-label", "Hide details");
          loadBuildDetails(buildId, detailsRow);
        } else {
          detailsRow.classList.add("hidden");
          button.classList.remove("active");
          button.setAttribute("title", "Show details");
          button.setAttribute("aria-label", "Show details");
        }
      }

      function wireBuildLogs(container, buildId, running) {
        const panel = container.querySelector(".log-panel");
        if (!panel) {
          return;
        }
        const output = panel.querySelector(".log-output");
        const note = panel.querySelector(".log-note");
        const load = () => loadBuildLogs(buildId, panel);
        panel.querySelectorAll("button[data-log-action]").forEach((button) => {
          button.addEventListener("click", (event) => {
            event.preventDefault();
            load();
          });
        });
        if (output && !running) {
          output.textContent = "Build not running. Start it to generate logs.";
        } else if (running) {
          load();
        }
        if (note) {
          note.classList.add("hidden");
        }
      }

      function clearBuildLogOutput(buildId, message) {
        if (!buildId || buildId === "-") {
          return;
        }
        const outputs = document.querySelectorAll("pre[data-log-output]");
        outputs.forEach((output) => {
          if (output.dataset.logOutput !== buildId) {
            return;
          }
          output.textContent = message || "Logs cleared. Load to see new output.";
          const panel = output.closest(".log-panel");
          if (!panel) {
            return;
          }
          const note = panel.querySelector(".log-note");
          if (note) {
            note.classList.add("hidden");
          }
        });
      }

      async function loadBuildLogs(buildId, panel) {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module || !panel) {
          return;
        }
        const output = panel.querySelector(".log-output");
        const note = panel.querySelector(".log-note");
        if (!output) {
          return;
        }
        output.textContent = "Loading logs...";
        if (note) {
          note.classList.add("hidden");
        }
        try {
          const path = apiPath("/modules/" + module + "/builds/" + buildId + "/logs") + "?lines=200";
          const data = await apiRequest("GET", path);
          if (!isSelectionCurrent(token, module)) {
            return;
          }
          const content = stripAnsi((data && data.log_output) ? String(data.log_output) : "");
          output.textContent = content || "No logs available yet.";
          if (note) {
            if (data && data.truncated) {
              note.textContent = "Log output truncated.";
              note.classList.remove("hidden");
            } else {
              note.classList.add("hidden");
            }
          }
        } catch (err) {
          if (!isSelectionCurrent(token, module)) {
            return;
          }
          output.textContent = "Failed to load logs.";
          if (note) {
            note.classList.add("hidden");
          }
          handleError(err);
        }
      }

      async function openBuildLink(buildId, suffix, label) {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module || !buildId || buildId === "-") {
          return;
        }
        setActivity("Loading " + label + " link for " + buildId + "...");
        const data = await apiRequest("GET", apiPath("/modules/" + module + "/builds/" + buildId + "/status"));
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        const port = data.port || 0;
        const base = port ? moduleLinkFromPort(port) : "";
        if (!base) {
          setActivity("No port available for " + label + " link.", true);
          return;
        }
        if (!data.running) {
          setActivity("Build not running; opening link anyway.", true);
        } else {
          setActivity("Opening " + label + " link...");
        }
        window.open(base + suffix, "_blank", "noopener");
      }

      function updateSignerMode() {
        if (!ui.signerMode) {
          return;
        }
        if (isLocalMode) {
          ui.signerMode.textContent = "Local mode (no HMAC)";
          return;
        }
        if (hasWebCrypto()) {
          ui.signerMode.textContent = "Signer: WebCrypto (secure context)";
        } else {
          ui.signerMode.textContent = "Signer: JS fallback (http)";
        }
      }

      function applyModeLabels() {
        if (!isLocalMode) {
          return;
        }
        const badge = document.querySelector(".badge");
        if (badge) {
          badge.textContent = "Deploy | Local";
        }
       
        const subtitle = document.querySelector(".hero-text p");
        if (subtitle) {
          subtitle.textContent = "Local build manager.";
        }
      }

      function closeMenu() {
        if (ui.menuPanel) {
          ui.menuPanel.classList.add("hidden");
        }
      }

      function toggleMenu(event) {
        if (!ui.menuPanel) {
          return;
        }
        if (event) {
          event.stopPropagation();
        }
        ui.menuPanel.classList.toggle("hidden");
      }

      function moduleLinkFromPort(port) {
        if (!port) {
          return "";
        }
        try {
          const base = new URL(getBaseUrl());
          const host = base.hostname;
          const scheme = base.protocol === "https:" ? "https:" : "http:";
          return scheme + "//" + host + ":" + port;
        } catch (err) {
          return "";
        }
      }


      async function apiRequest(method, path, bodyObj) {
        const baseUrl = isLocalMode ? window.location.origin : getBaseUrl();
        const url = new URL(path, baseUrl);
        const body = bodyObj ? JSON.stringify(bodyObj) : "";
        const headers = {
          "Accept": "application/json"
        };
        if (!isLocalMode) {
          const secret = getSecret();
          if (!secret) {
            throw new Error("Missing HMAC secret.");
          }
          const ts = Math.floor(Date.now() / 1000).toString();
          const nonce = randomHex(32);
          const bodyHash = await sha256Hex(body);
          const canonical = [method, url.pathname, bodyHash, ts, nonce].join("\n");
          const signature = await hmacHex(secret, canonical);
          headers["X-HB-Timestamp"] = ts;
          headers["X-HB-Nonce"] = nonce;
          headers["X-HB-Signature"] = signature;
        }
        if (bodyObj) {
          headers["Content-Type"] = "application/json";
        }

        let response;
        try {
          response = await fetch(url.toString(), {
            method,
            headers,
            body: bodyObj ? body : undefined
          });
        } catch (err) {
          setApiStatus("offline");
          throw err;
        }
        if (response.ok) {
          setApiStatus("online");
        } else {
          setApiStatus("error " + response.status);
        }
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(payload.error || response.statusText);
        }
        return payload;
      }

      function setLocalConnectionDetails(status) {
        if (!isLocalMode) {
          return;
        }
        if (ui.localApiBase) {
          ui.localApiBase.value = window.location.origin;
        }
        if (ui.localTargetName) {
          ui.localTargetName.value = (status.target || "").trim() || "-";
        }
        if (ui.localTargetApi) {
          ui.localTargetApi.value = (status.target_api || "").trim() || "-";
        }
        if (ui.localTargetRoot) {
          ui.localTargetRoot.value = (status.target_root || "").trim() || "-";
        }
      }

      async function refreshServerStatus() {
        if (!isLocalMode && !getSecret()) {
          return;
        }
        const data = await apiRequest("GET", apiPath("/status"));
        if (ui.apiVersion) {
          ui.apiVersion.textContent = (data.version || "").trim() || "-";
        }
        if (ui.apiVersionPlugins) {
          ui.apiVersionPlugins.textContent = (data.version || "").trim() || "-";
        }
        setLocalConnectionDetails(data);
        state.logsEnabled = data.logs_enabled !== false;
      }

      function startServerStatusTick() {
        if (serverStatusTimer) {
          return;
        }
        serverStatusTimer = setInterval(() => {
          refreshServerStatus().catch(() => {});
        }, 30000);
      }

      function canAutoLoadPlugins() {
        if (isLocalMode) {
          return true;
        }
        return !!getSecret();
      }

      function canAutoLoadCustomPlugins() {
        const module = state.pluginModule || state.selectedModule || "";
        if (!module) {
          return false;
        }
        if (isLocalMode) {
          return true;
        }
        const buildId = state.pluginBuild || state.currentBuild || "";
        return !!buildId;
      }

      async function autoLoadPlugins() {
        if (!canAutoLoadPlugins()) {
          return;
        }
        if (!state.modules.length) {
          await loadModules();
        }
        await loadGlobalPlugins();
        if (canAutoLoadCustomPlugins()) {
          await loadCustomPlugins();
        }
      }

      function autoLoadCustomPlugins() {
        if (!canAutoLoadPlugins()) {
          return;
        }
        if (!canAutoLoadCustomPlugins()) {
          return;
        }
        loadCustomPlugins().catch(handleError);
      }

      async function findRunningModule(modules) {
        for (const module of modules) {
          try {
            const data = await apiRequest("GET", apiPath("/modules/" + module + "/status"));
            if (data.running) {
              return module;
            }
          } catch (err) {
            continue;
          }
        }
        return "";
      }

      function setView(view) {
        const target = view === "plugins" ? "plugins" : "modules";
        state.view = target;
        try {
          localStorage.setItem(storageKeys.view, target);
        } catch (e) {}
        const showModules = target === "modules";
        if (ui.modulesView) {
          ui.modulesView.classList.toggle("hidden", !showModules);
        }
        if (ui.pluginsView) {
          ui.pluginsView.classList.toggle("hidden", showModules);
        }
        if (ui.viewModules) {
          ui.viewModules.classList.toggle("active", showModules);
          ui.viewModules.classList.toggle("ghost", !showModules);
        }
        if (ui.viewPlugins) {
          ui.viewPlugins.classList.toggle("active", !showModules);
          ui.viewPlugins.classList.toggle("ghost", showModules);
        }
        if (!showModules) {
          renderPluginModules();
          renderPluginBuilds();
          autoLoadPlugins().catch(handleError);
        }
      }

      function pluginShortName(fullName) {
        const text = String(fullName || "");
        const idx = text.lastIndexOf("/");
        return idx >= 0 ? text.slice(idx + 1) : text;
      }

      function toCamelCase(value) {
        const text = String(value || "");
        let out = "";
        let upperNext = true;
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          if (ch === "-" || ch === "_") {
            upperNext = true;
            continue;
          }
          if (upperNext) {
            out += ch.toUpperCase();
            upperNext = false;
          } else {
            out += ch;
          }
        }
        return out;
      }

      function pluginBinaryBase(meta) {
        if (meta && typeof meta.binary === "string" && meta.binary.trim()) {
          return meta.binary.trim().replace(/\.so$/, "");
        }
        const source = meta && typeof meta.source === "string" ? meta.source.trim() : "";
        if (!source) {
          return "";
        }
        const trimmed = source.endsWith(".go") ? source.slice(0, -3) : source;
        return toCamelCase(trimmed);
      }

      function pluginConfigName(meta, version) {
        const base = pluginBinaryBase(meta);
        if (!base || !version) {
          return "";
        }
        return base + "@" + version;
      }

      function splitConfigName(configName) {
        const text = String(configName || "");
        const idx = text.lastIndexOf("@");
        if (idx === -1) {
          return { name: text, version: "" };
        }
        return { name: text.slice(0, idx), version: text.slice(idx + 1) };
      }

      function compareVersion(a, b) {
        const split = (value) => {
          const raw = String(value || "").trim().replace(/^v/, "");
          const parts = raw.split("-");
          const main = parts[0] || "";
          const pre = parts.slice(1).join("-") || "";
          const nums = main.split(".").map((item) => {
            const num = parseInt(item, 10);
            return Number.isNaN(num) ? item : num;
          });
          return { nums: nums, pre: pre };
        };
        const va = split(a);
        const vb = split(b);
        const max = Math.max(va.nums.length, vb.nums.length);
        for (let i = 0; i < max; i++) {
          const na = va.nums[i] === undefined ? 0 : va.nums[i];
          const nb = vb.nums[i] === undefined ? 0 : vb.nums[i];
          if (typeof na === "number" && typeof nb === "number") {
            if (na !== nb) {
              return na - nb;
            }
          } else {
            const sa = String(na);
            const sb = String(nb);
            if (sa !== sb) {
              return sa < sb ? -1 : 1;
            }
          }
        }
        if (va.pre && !vb.pre) {
          return -1;
        }
        if (!va.pre && vb.pre) {
          return 1;
        }
        if (va.pre === vb.pre) {
          return 0;
        }
        return va.pre < vb.pre ? -1 : 1;
      }

      function formatPluginStatus(status) {
        const value = String(status || "").trim();
        if (!value) {
          return "-";
        }
        if (value === "source-missing") {
          return "source missing";
        }
        return value.replace(/_/g, " ");
      }

      function setPluginRowsMessage(container, message) {
        if (!container) {
          return;
        }
        container.innerHTML = "<tr><td colspan=\"5\" class=\"note\">" + message + "</td></tr>";
      }

      function wireCopyButtons(container) {
        if (!container) {
          return;
        }
        container.querySelectorAll(".copy-btn").forEach((button) => {
          button.addEventListener("click", () => {
            if (button.disabled) {
              return;
            }
            const value = button.dataset.copy || "";
            copyText(value)
              .then(() => setActivity("Copied to clipboard."))
              .catch(() => setActivity("Copy failed.", true));
          });
        });
      }

      function renderPluginModules() {
        if (!ui.pluginModule) {
          return;
        }
        ui.pluginModule.innerHTML = "";
        if (!state.modules.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "Load modules first";
          option.disabled = true;
          option.selected = true;
          ui.pluginModule.appendChild(option);
          state.pluginModule = "";
          return;
        }
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select module";
        placeholder.disabled = true;
        ui.pluginModule.appendChild(placeholder);
        state.modules.forEach((module) => {
          const option = document.createElement("option");
          option.value = module;
          option.textContent = module;
          ui.pluginModule.appendChild(option);
        });
        const current = state.pluginModule || state.selectedModule || "";
        if (current && state.modules.includes(current)) {
          ui.pluginModule.value = current;
          state.pluginModule = current;
        } else {
          ui.pluginModule.value = "";
          placeholder.selected = true;
          state.pluginModule = "";
        }
      }

      function renderPluginBuilds() {
        if (!ui.pluginBuild) {
          return;
        }
        ui.pluginBuild.innerHTML = "";
        if (!state.selectedModule || !state.builds.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = state.selectedModule ? "No builds" : "Select module";
          option.disabled = true;
          option.selected = true;
          ui.pluginBuild.appendChild(option);
          state.pluginBuild = "";
          return;
        }
        const buildIds = [];
        state.builds.forEach((build) => {
          if (build.is_dev) {
            return;
          }
          const buildId = build.build_id;
          if (!buildId) {
            return;
          }
          buildIds.push(buildId);
          const option = document.createElement("option");
          const shortId = shortenValue(buildId);
          const label = build.moduleversion ? shortId + " / " + build.moduleversion : shortId;
          option.value = buildId;
          option.textContent = label;
          option.title = buildId;
          ui.pluginBuild.appendChild(option);
        });
        if (!buildIds.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "No builds";
          option.disabled = true;
          option.selected = true;
          ui.pluginBuild.appendChild(option);
          state.pluginBuild = "";
          return;
        }
        let selected = state.pluginBuild;
        if (!selected || !buildIds.includes(selected)) {
          selected = state.currentBuild || state.runningBuild || buildIds[0];
        }
        ui.pluginBuild.value = selected;
        state.pluginBuild = selected;
      }

      async function loadGlobalPlugins(silent) {
        if (!silent) {
          setActivity("Loading global plugins...");
          setPluginRowsMessage(ui.globalPluginRows, "Loading global plugins...");
        }
        const responses = await Promise.all([
          apiRequest("GET", apiPath("/plugins/global/index")),
          apiRequest("GET", apiPath("/plugins/global"))
        ]);
        const index = responses[0] ? responses[0].plugins : {};
        const installed = responses[1] ? responses[1].plugins : [];
        renderGlobalPlugins(index, installed);
        if (!silent) {
          setActivity("Global plugins updated.");
        }
      }

      function renderGlobalPlugins(index, installed) {
        if (!ui.globalPluginRows) {
          return;
        }
        const installedList = Array.isArray(installed) ? installed : [];
        const installedMap = new Map();
        installedList.forEach((entry) => {
          if (entry && entry.config_name) {
            installedMap.set(entry.config_name, entry);
          }
        });
        const rows = [];
        const seen = new Set();
        const indexEntries = index && typeof index === "object" ? Object.entries(index) : [];
        indexEntries.forEach(([fullName, versions]) => {
          const shortName = pluginShortName(fullName);
          const versionEntries = versions && typeof versions === "object" ? Object.entries(versions) : [];
          versionEntries.forEach(([version, meta]) => {
            const configName = pluginConfigName(meta, version);
            const status = configName && installedMap.has(configName) ? "installed" : (configName ? "missing" : "unknown");
            rows.push({
              name: shortName || fullName,
              version: version || (meta && meta.version) || "",
              configName: configName,
              status: status,
              actionName: shortName || fullName,
              description: meta && meta.description,
              fromIndex: true
            });
            if (configName) {
              seen.add(configName);
            }
          });
        });
        installedList.forEach((entry) => {
          if (!entry || !entry.config_name || seen.has(entry.config_name)) {
            return;
          }
          const parts = splitConfigName(entry.config_name);
          rows.push({
            name: entry.name || parts.name,
            version: entry.version || parts.version,
            configName: entry.config_name,
            status: "installed",
            actionName: entry.name || parts.name,
            description: "",
            fromIndex: false
          });
          seen.add(entry.config_name);
        });
        if (!rows.length) {
          setPluginRowsMessage(ui.globalPluginRows, "No plugins found.");
          return;
        }
        rows.sort((a, b) => {
          const nameCmp = String(a.name || "").localeCompare(String(b.name || ""));
          if (nameCmp !== 0) {
            return nameCmp;
          }
          return compareVersion(b.version, a.version);
        });
        ui.globalPluginRows.innerHTML = "";
        rows.forEach((entry) => {
          const row = document.createElement("tr");
          const pluginName = entry.name || "-";
          const version = entry.version || "-";
          const statusText = formatPluginStatus(entry.status);
          const statusClass = entry.status === "installed" ? "status-pill status-installed" : "status-pill";
          const configName = entry.configName || "";
          const configText = configName || "-";
          const configTitle = configName ? ` title="${escapeAttr(configName)}"` : "";
          const copyDisabled = configName ? "" : " disabled";
          const pluginTitle = entry.description ? ` title="${escapeAttr(entry.description)}"` : "";
          const actionName = entry.actionName || "";
          const actionDisabled = !(actionName && entry.version);
          const actionAttr = actionName ? ` data-plugin="${escapeAttr(actionName)}" data-version="${escapeAttr(entry.version || "")}"` : "";
          const actionItems = [];
          if (entry.status === "installed") {
            if (entry.fromIndex) {
              actionItems.push({
                action: "rebuild",
                label: "Rebuild",
                icon: icons.rebuild,
                attrs: actionAttr,
                disabled: actionDisabled
              });
            }
            actionItems.push({
              action: "remove",
              label: "Remove",
              icon: icons.remove,
              className: "danger",
              attrs: actionAttr,
              disabled: actionDisabled
            });
          } else {
            actionItems.push({
              action: "install",
              label: "Install",
              icon: icons.install,
              attrs: actionAttr,
              disabled: actionDisabled
            });
          }
          const actionMenu = renderRowMenu(actionItems);
          row.innerHTML = `
            <td data-label="Plugin"${pluginTitle}>${escapeAttr(pluginName)}</td>
            <td data-label="Version">${escapeAttr(version)}</td>
            <td data-label="Status"><span class="${statusClass}">${escapeAttr(statusText)}</span></td>
            <td data-label="Config">
              <div class="value-row">
                <span class="mono wrap"${configTitle}>${escapeAttr(configText)}</span>
                <button class="copy-btn" data-copy="${escapeAttr(configName)}"${copyDisabled} type="button">Copy</button>
              </div>
            </td>
            <td data-label="Action">
              <div class="row-actions">
                ${actionMenu}
              </div>
            </td>
          `;
          ui.globalPluginRows.appendChild(row);
        });
        wireCopyButtons(ui.globalPluginRows);
        wireRowMenus(ui.globalPluginRows);
        ui.globalPluginRows.querySelectorAll("button[data-action]").forEach((button) => {
          button.addEventListener("click", () => {
            if (button.disabled) {
              return;
            }
            closeRowMenus();
            const action = button.dataset.action || "";
            const name = button.dataset.plugin || "";
            const version = button.dataset.version || "";
            if (!action || !name || !version) {
              setActivity("Missing plugin details for action.", true);
              return;
            }
            button.disabled = true;
            runGlobalPluginAction(action, name, version)
              .catch(handleError)
              .finally(() => {
                button.disabled = false;
              });
          });
        });
      }

      async function runGlobalPluginAction(action, name, version) {
        if (action === "remove") {
          const confirmText = "Remove plugin " + name + "@" + version + "?";
          if (!confirm(confirmText)) {
            return;
          }
        }
        const actionLabel = action === "install"
          ? "Installing " + name + "@" + version
          : action === "rebuild"
            ? "Rebuilding " + name + "@" + version
            : "Removing " + name + "@" + version;
        const ok = await runPluginTask(
          actionLabel,
          () => apiRequest("POST", apiPath("/plugins/global/" + action), { name: name, version: version })
        );
        if (ok) {
          await loadGlobalPlugins(true);
        }
      }

      async function loadCustomPlugins(silent) {
        const module = state.pluginModule || state.selectedModule || "";
        if (!module) {
          setActivity("Select a module first.", true);
          return;
        }
        let buildId = "";
        if (!isLocalMode) {
          buildId = state.pluginBuild || state.currentBuild || "";
          if (!buildId) {
            setActivity("Select a build first.", true);
            return;
          }
        }
        if (!silent) {
          setActivity("Loading custom plugins for " + module + "...");
          setPluginRowsMessage(ui.customPluginRows, "Loading custom plugins...");
        }
        const params = new URLSearchParams({ module: module });
        if (!isLocalMode) {
          params.set("build_id", buildId);
        }
        const data = await apiRequest("GET", apiPath("/plugins/custom?" + params.toString()));
        renderCustomPlugins(data.plugins || []);
        if (!silent) {
          setActivity("Custom plugins loaded.");
        }
      }

      function renderCustomPlugins(plugins) {
        if (!ui.customPluginRows) {
          return;
        }
        const list = Array.isArray(plugins) ? plugins : [];
        if (!list.length) {
          setPluginRowsMessage(ui.customPluginRows, "No plugins configured for this build.");
          return;
        }
        ui.customPluginRows.innerHTML = "";
        list.forEach((plugin) => {
          const configName = plugin.config_name || "";
          const pluginName = plugin.name || configName || "-";
          const version = plugin.version || "-";
          const statusText = formatPluginStatus(plugin.status);
          const statusClass = plugin.status === "installed" ? "status-pill status-installed" : "status-pill";
          const sourcePath = plugin.source_path || "";
          const hasSource = !!String(sourcePath || "").trim();
          const hasConfig = !!String(configName || "").trim();
          const canCompile = hasSource && hasConfig;
          const canRemove = hasConfig && plugin.status === "installed";
          const actionLabel = plugin.status === "installed" ? "Rebuild" : "Compile";
          const actionText = !hasSource ? "Missing source" : (hasConfig ? actionLabel : "Missing config");
          const actionDisabled = !canCompile;
          const pluginTitle = sourcePath ? ` title="${escapeAttr(sourcePath)}"` : "";
          const configTitle = configName ? ` title="${escapeAttr(configName)}"` : "";
          const copyDisabled = configName ? "" : " disabled";
          const moduleName = plugin.module || state.pluginModule || state.selectedModule || "";
          const buildId = plugin.build_id || state.pluginBuild || "";
          const actionAttr = ` data-plugin="${escapeAttr(configName)}" data-module="${escapeAttr(moduleName)}" data-build="${escapeAttr(buildId)}" data-status="${escapeAttr(plugin.status || "")}"`;
          const actionItems = [
            {
              action: "compile",
              label: actionText,
              icon: icons.compile,
              attrs: actionAttr,
              disabled: actionDisabled
            }
          ];
          if (canRemove) {
            actionItems.push({
              action: "remove",
              label: "Remove",
              icon: icons.remove,
              className: "danger",
              attrs: actionAttr,
              disabled: false
            });
          }
          const actionMenu = renderRowMenu(actionItems);
          const row = document.createElement("tr");
          row.innerHTML = `
            <td data-label="Plugin"${pluginTitle}>${escapeAttr(pluginName)}</td>
            <td data-label="Version">${escapeAttr(version)}</td>
            <td data-label="Status"><span class="${statusClass}">${escapeAttr(statusText)}</span></td>
            <td data-label="Config">
              <div class="value-row">
                <span class="mono wrap"${configTitle}>${escapeAttr(configName || "-")}</span>
                <button class="copy-btn" data-copy="${escapeAttr(configName)}"${copyDisabled} type="button">Copy</button>
              </div>
            </td>
            <td data-label="Action">
              <div class="row-actions">
                ${actionMenu}
              </div>
            </td>
          `;
          ui.customPluginRows.appendChild(row);
        });
        wireCopyButtons(ui.customPluginRows);
        wireRowMenus(ui.customPluginRows);
        ui.customPluginRows.querySelectorAll("button[data-action=\"compile\"]").forEach((button) => {
          button.addEventListener("click", () => {
            if (button.disabled) {
              return;
            }
            closeRowMenus();
            const configName = button.dataset.plugin || "";
            if (!configName) {
              setActivity("Missing plugin config name.", true);
              return;
            }
            const module = button.dataset.module || state.pluginModule || state.selectedModule || "";
            const buildId = button.dataset.build || state.pluginBuild || "";
            const plugin = {
              config_name: configName,
              module: module,
              build_id: buildId,
              status: button.dataset.status || ""
            };
            button.disabled = true;
            compileCustomPlugin(plugin)
              .catch(handleError)
              .finally(() => {
                button.disabled = false;
              });
          });
        });
        ui.customPluginRows.querySelectorAll("button[data-action=\"remove\"]").forEach((button) => {
          button.addEventListener("click", () => {
            if (button.disabled) {
              return;
            }
            closeRowMenus();
            const configName = button.dataset.plugin || "";
            if (!configName) {
              setActivity("Missing plugin config name.", true);
              return;
            }
            const module = button.dataset.module || state.pluginModule || state.selectedModule || "";
            const buildId = button.dataset.build || state.pluginBuild || "";
            const plugin = {
              config_name: configName,
              module: module,
              build_id: buildId
            };
            button.disabled = true;
            removeCustomPlugin(plugin)
              .catch(handleError)
              .finally(() => {
                button.disabled = false;
              });
          });
        });
      }

      async function compileCustomPlugin(plugin) {
        const module = plugin.module || state.pluginModule || state.selectedModule || "";
        if (!module) {
          setActivity("Select a module first.", true);
          return;
        }
        if (!plugin.config_name) {
          setActivity("Missing plugin config name.", true);
          return;
        }
        let buildId = plugin.build_id || state.pluginBuild || "";
        if (!isLocalMode && !buildId) {
          setActivity("Select a build first.", true);
          return;
        }
        const verb = plugin.status === "installed" ? "Rebuilding" : "Compiling";
        const label = verb + " " + plugin.config_name;
        const body = {
          module: module,
          plugin: plugin.config_name
        };
        if (!isLocalMode) {
          body.build_id = buildId;
        }
        const ok = await runPluginTask(label, () => apiRequest("POST", apiPath("/plugins/custom/compile"), body));
        if (ok) {
          await loadCustomPlugins(true);
        }
      }

      async function removeCustomPlugin(plugin) {
        const module = plugin.module || state.pluginModule || state.selectedModule || "";
        if (!module) {
          setActivity("Select a module first.", true);
          return;
        }
        if (!plugin.config_name) {
          setActivity("Missing plugin config name.", true);
          return;
        }
        let buildId = plugin.build_id || state.pluginBuild || "";
        if (!isLocalMode && !buildId) {
          setActivity("Select a build first.", true);
          return;
        }
        const confirmText = "Remove binary for " + plugin.config_name + "?";
        if (!confirm(confirmText)) {
          return;
        }
        const label = "Removing " + plugin.config_name;
        const body = {
          module: module,
          plugin: plugin.config_name
        };
        if (!isLocalMode) {
          body.build_id = buildId;
        }
        const ok = await runPluginTask(label, () => apiRequest("POST", apiPath("/plugins/custom/remove"), body));
        if (ok) {
          await loadCustomPlugins(true);
        }
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function runPluginTask(label, startRequest) {
        try {
          setActivity(label + "...");
          const task = await startRequest();
          const taskId = task.task_id || task.id || "";
          if (!taskId) {
            setActivity("Plugin task ID missing.", true);
            return false;
          }
          return await waitForPluginTask(taskId, label);
        } catch (err) {
          setActivity(err.message || String(err), true);
          return false;
        }
      }

      async function waitForPluginTask(taskId, label) {
        let lastStatus = "";
        while (true) {
          const data = await apiRequest("GET", apiPath("/plugins/tasks/" + taskId));
          const status = data.status || "";
          if (status && status !== lastStatus) {
            lastStatus = status;
            setActivity(label + " (" + status + ")...");
          }
          if (status === "done") {
            const log = await fetchPluginTaskLogs(taskId);
            const output = log ? stripAnsi(log) : "";
            setActivity(output ? label + " complete.\n" + output : label + " complete.");
            return true;
          }
          if (status === "error") {
            const log = await fetchPluginTaskLogs(taskId);
            const message = data.message || "Plugin task failed.";
            const output = log ? stripAnsi(log) : "";
            setActivity(output ? message + "\n" + output : message, true);
            return false;
          }
          await sleep(1000);
        }
      }

      async function fetchPluginTaskLogs(taskId) {
        try {
          const data = await apiRequest("GET", apiPath("/plugins/tasks/" + taskId + "/logs"));
          return data.log || "";
        } catch (err) {
          return "";
        }
      }

      function renderModules() {
        ui.moduleList.innerHTML = "";
        state.modules.forEach((module) => {
          const item = document.createElement("li");
          item.className = "module-item" + (module === state.selectedModule ? " active" : "");
          const count = typeof state.buildCounts[module] === "number" ? state.buildCounts[module] : null;
          const countLabel = count === null ? "â€”" : (String(count) + " builds");
          item.innerHTML = "<span>" + module + "</span><span class=\"module-count\">" + countLabel + "</span>";
          item.addEventListener("click", () => selectModule(module));
          ui.moduleList.appendChild(item);
        });
        renderPluginModules();
      }

      function renderBuilds() {
        ui.buildRows.innerHTML = "";
        if (!state.builds.length) {
          const row = document.createElement("tr");
          row.innerHTML = "<td colspan=\"6\" class=\"note\">No builds found.</td>";
          ui.buildRows.appendChild(row);
          renderPluginBuilds();
          return;
        }
        state.builds.forEach((build) => {
          const row = document.createElement("tr");
          const isDev = !!build.is_dev;
          const buildId = build.build_id || "-";
          const buildShort = isDev ? "source module" : shortenValue(buildId);
          const builtAt = formatRelativeTime(build.built_at || "");
          const builtTitle = build.built_at ? formatDate(build.built_at) : "";
          const isRunning = state.runningBuild && buildId === state.runningBuild;
          const isProduction = !!build.production;
          const modeDefaultSelected = isProduction ? "" : " selected";
          const modeProductionSelected = isProduction ? " selected" : "";
          const isDisabled = buildId === "-";
          const modeDisabled = (isDev || isDisabled) ? " disabled" : "";
          const buildAttr = ` data-build="${escapeAttr(buildId)}"`;
          const detailsDisabled = isDisabled ? " disabled" : "";
          if (isDev) {
            row.classList.add("build-row-dev");
          }
          const actionItems = [];
          if (isRunning) {
            actionItems.push({
              action: "restart",
              label: "Restart",
              icon: icons.restart,
              attrs: buildAttr,
              disabled: isDisabled
            });
            actionItems.push({
              action: "stop",
              label: "Stop",
              icon: icons.stop,
              className: "danger",
              attrs: buildAttr,
              disabled: isDisabled
            });
          } else {
            actionItems.push({
              action: "start",
              label: "Start",
              icon: icons.start,
              attrs: buildAttr,
              disabled: isDisabled
            });
          }
          if (isLocalMode) {
            if (!isDev) {
              actionItems.push({
                action: "push",
                label: "Push build",
                icon: icons.push,
                attrs: buildAttr,
                disabled: isDisabled
              });
            }
          }
          actionItems.push({
            action: "link",
            label: "Open runtime",
            icon: icons.link,
            attrs: buildAttr,
            disabled: isDisabled
          });
          actionItems.push({
            action: "dashboard",
            label: "Open dashboard",
            icon: icons.dashboard,
            attrs: buildAttr,
            disabled: isDisabled
          });
          actionItems.push({
            action: "details",
            label: "Details",
            icon: icons.details,
            attrs: buildAttr,
            disabled: isDisabled
          });
          if (!isDev) {
            actionItems.push({
              action: "delete",
              label: "Delete build",
              icon: icons.delete,
              className: "danger",
              attrs: buildAttr,
              disabled: isDisabled
            });
          }
          const actionMenu = renderRowMenu(actionItems);
          row.innerHTML = `
            <td data-label="Build">
              <div class="value-row">
                <span class="mono wrap" title="${buildId}">${buildShort}</span>
                <button class="copy-btn" data-copy="${buildId}" type="button">Copy</button>
              </div>
            </td>
            <td data-label="Version">${isDev ? (build.moduleversion || "dev") : (build.moduleversion || "-")}</td>
            <td data-label="Built" title="${builtTitle}">${builtAt}</td>
            <td data-label="Mode">
              <select class="mode-select" data-action="mode" data-build="${buildId}"${modeDisabled}>
                <option value="default"${modeDefaultSelected}>Default</option>
                <option value="production"${modeProductionSelected}>Production</option>
              </select>
            </td>
            <td data-label="Status">
              <span class="status-pill ${isRunning ? "status-installed" : ""}">${isRunning ? "running" : "stopped"}</span>
            </td>
            <td data-label="Action">
              <div class="row-actions">
                <button class="icon-toggle" data-action="details" data-build="${escapeAttr(buildId)}"${detailsDisabled} type="button" aria-label="Details">
                  ${icons.details}
                </button>
                ${actionMenu}
              </div>
            </td>
          `;
          const detailsRow = document.createElement("tr");
          detailsRow.className = "details-row hidden";
          detailsRow.innerHTML = `
            <td colspan="6">
              <div class="build-details" data-build="${buildId}">
                <span class="note">Open details to load build status.</span>
              </div>
            </td>
          `;
          row.querySelectorAll("button[data-action]").forEach((element) => {
            const action = element.dataset.action;
            element.addEventListener("click", () => {
              if (element.disabled) {
                return;
              }
              closeRowMenus();
              if (action === "start") {
                activateBuild(buildId).catch(handleError);
              } else if (action === "restart") {
                restartModule(buildId).catch(handleError);
              } else if (action === "stop") {
                stopModule().catch(handleError);
              } else if (action === "details") {
                toggleBuildDetails(buildId, detailsRow, element);
              } else if (action === "link") {
                openBuildLink(buildId, "", "runtime").catch(handleError);
              } else if (action === "dashboard") {
                openBuildLink(buildId, "/dashboard", "dashboard").catch(handleError);
              } else if (action === "push") {
                pushBuild(buildId).catch(handleError);
              } else if (action === "delete") {
                deleteBuild(buildId).catch(handleError);
              }
            });
          });
          row.querySelectorAll("select[data-action=\"mode\"]").forEach((select) => {
            select.addEventListener("change", (event) => {
              const value = event.target.value;
              setBuildProduction(buildId, value === "production").catch(handleError);
            });
          });
          row.querySelectorAll(".copy-btn").forEach((button) => {
            button.addEventListener("click", () => {
              const value = button.dataset.copy || "";
              copyText(value)
                .then(() => setActivity("Copied to clipboard."))
                .catch(() => setActivity("Copy failed.", true));
            });
          });
          ui.buildRows.appendChild(row);
          ui.buildRows.appendChild(detailsRow);
        });
        wireRowMenus(ui.buildRows);
        renderPluginBuilds();
      }

      function updateStatus(status) {
        const fullBuild = status.current && status.current !== "-" ? status.current : "";
        state.currentBuild = fullBuild;
        state.runningBuild = status.running_build || "";
        updateRollbackTarget();
      }

      async function loadModules() {
        setActivity("Loading modules...");
        state.selectionToken += 1;
        const data = await apiRequest("GET", apiPath("/modules"));
        state.modules = data.modules || [];
        state.selectedModule = "";
        state.pluginModule = "";
        state.pluginBuild = "";
        state.buildCounts = {};
        renderModules();
        renderPluginBuilds();
        setPluginRowsMessage(ui.customPluginRows, "Select a module to load custom plugins.");
        ui.buildRows.innerHTML = "<tr><td colspan=\"6\" class=\"note\">Select a module to load builds.</td></tr>";
        updateStatus({ module: "", current: "", port: "-", versions: "-" });
        ui.refreshStatus.disabled = true;
        state.runningBuild = "";
        state.currentBuild = "";
        updateRollbackTarget();
        const saved = getSavedModule();
        let autoSelect = "";
        if (saved && state.modules.includes(saved)) {
          autoSelect = saved;
        } else if (state.modules.length === 1) {
          autoSelect = state.modules[0];
        } else if (!isLocalMode && state.modules.length > 1) {
          setActivity("Detecting running module...");
          autoSelect = await findRunningModule(state.modules);
        }
        if (autoSelect) {
          await selectModule(autoSelect);
        }
        setActivity("Modules loaded.");
        refreshServerStatus().catch(handleError);
      }

      async function selectModule(module) {
        state.selectedModule = module;
        state.pluginModule = module;
        state.pluginBuild = "";
        saveModule(module);
        renderModules();
        state.builds = [];
        renderPluginBuilds();
        state.runningBuild = "";
        state.currentBuild = "";
        setPluginRowsMessage(
          ui.customPluginRows,
          isLocalMode ? "Press Load to view custom plugins." : "Select a build to load custom plugins."
        );
        ui.buildRows.innerHTML = "<tr><td colspan=\"6\" class=\"note\">Loading builds...</td></tr>";
        ui.refreshStatus.disabled = true;
        updateRollbackTarget();
        const token = state.selectionToken + 1;
        state.selectionToken = token;
        await refreshStatus(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await loadBuilds(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        ui.refreshStatus.disabled = false;
        updateRollbackTarget();
      }

      async function loadBuilds(token, moduleOverride) {
        const module = moduleOverride || state.selectedModule;
        const requestToken = typeof token === "number" ? token : state.selectionToken;
        if (!module) {
          return;
        }
        setActivity("Loading builds for " + module + "...");
        const data = await apiRequest("GET", apiPath("/modules/" + module + "/builds"));
        if (!isSelectionCurrent(requestToken, module)) {
          return;
        }
        state.builds = data.versions || [];
        state.builds.sort((a, b) => {
          const aDev = !!(a && a.is_dev);
          const bDev = !!(b && b.is_dev);
          if (aDev !== bDev) {
            return aDev ? -1 : 1;
          }
          const aTime = buildTimestamp(a && a.built_at);
          const bTime = buildTimestamp(b && b.built_at);
          if (aTime === bTime) {
            return String(b && b.build_id || "").localeCompare(String(a && a.build_id || ""));
          }
          return bTime - aTime;
        });
        state.buildCounts[module] = state.builds.filter((build) => !build.is_dev).length;
        renderBuilds();
        renderModules();
        updateRollbackTarget();
        setActivity("Builds updated.");
      }

      async function setBuildProduction(buildId, isProduction) {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module || !buildId || buildId === "-") {
          return;
        }
        const label = isProduction ? "production" : "default";
        setActivity("Setting mode for " + buildId + " to " + label + "...");
        const data = await apiRequest(
          "POST",
          apiPath("/modules/" + module + "/builds/" + buildId + "/production"),
          { production: isProduction }
        );
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        const target = state.builds.find((build) => build.build_id === buildId);
        if (target) {
          target.production = typeof data.production === "boolean" ? data.production : isProduction;
        }
        renderBuilds();
        updateRollbackTarget();
        if (data.restarted) {
          clearBuildLogOutput(buildId, "Logs cleared. Module restarting...");
          await refreshStatus(token, module);
          if (!isSelectionCurrent(token, module)) {
            return;
          }
          setActivity("Mode updated and module restarted.");
          return;
        }
        setActivity("Mode updated.");
      }

      async function refreshStatus(token, moduleOverride) {
        const module = moduleOverride || state.selectedModule;
        const requestToken = typeof token === "number" ? token : state.selectionToken;
        if (!module) {
          return;
        }
        setActivity("Refreshing status for " + module + "...");
        const data = await apiRequest("GET", apiPath("/modules/" + module + "/status"));
        if (!isSelectionCurrent(requestToken, module)) {
          return;
        }
        updateStatus(data);
        let isRunning = false;
        if (typeof data.running === "boolean") {
          isRunning = data.running;
        }
        if (isRunning && !state.runningBuild) {
          state.runningBuild = data.current || "";
        }
        renderBuilds();
        setActivity("Status updated.");
      }

      async function activateBuild(buildId) {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module) {
          return;
        }
        setActivity("Activating build " + buildId + "...");
        await apiRequest("POST", apiPath("/modules/" + module + "/activate"), { build_id: buildId });
        clearBuildLogOutput(buildId, "Logs cleared. Starting build...");
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await refreshStatus(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await loadBuilds(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        setActivity("Build activated.");
      }

      async function rollbackModule() {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module) {
          return;
        }
        setActivity("Rolling back " + module + "...");
        await apiRequest("POST", apiPath("/modules/" + module + "/rollback"));
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await refreshStatus(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await loadBuilds(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        setActivity("Rollback complete.");
      }

      async function restartModule(buildId) {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module) {
          return;
        }
        setActivity("Restarting " + module + "...");
        await apiRequest("POST", apiPath("/modules/" + module + "/restart"));
        clearBuildLogOutput(buildId, "Logs cleared. Restarting build...");
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await refreshStatus(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        setActivity("Restart completed.");
      }

      async function stopModule() {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module) {
          return;
        }
        setActivity("Stopping " + module + "...");
        await apiRequest("POST", apiPath("/modules/" + module + "/stop"));
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await refreshStatus(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        setActivity("Stop completed.");
      }

      async function deleteBuild(buildId) {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module) {
          return;
        }
        const confirmText = isLocalMode
          ? "Delete local build " + buildId + "? This removes the files."
          : "Delete build " + buildId + "? This stops it if running and removes files.";
        if (!confirm(confirmText)) {
          return;
        }
        setActivity("Deleting build " + buildId + "...");
        const data = await apiRequest("POST", apiPath("/modules/" + module + "/builds/" + buildId + "/delete"));
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await refreshStatus(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await loadBuilds(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        if (data && data.module_deleted) {
          setActivity("Build deleted; module folder removed.");
          return;
        }
        if (data && data.rollback_error) {
          setActivity("Build deleted, but rollback failed: " + data.rollback_error, true);
          return;
        }
        if (data && data.rollback) {
          setActivity("Build deleted; rolled back to " + shortenValue(data.rollback_build || "") + ".");
          return;
        }
        setActivity("Build deleted.");
      }

      async function buildLocalModule() {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module) {
          return;
        }
        setActivity("Building " + module + "...");
        const data = await apiRequest("POST", apiPath("/modules/" + module + "/build"));
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await loadBuilds(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        setActivity("Build complete: " + shortenValue(data.build_id || "") + ".");
      }

      async function pushBuild(buildId) {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module || !buildId || buildId === "-") {
          return;
        }
        setActivity("Pushing build " + buildId + "...");
        const data = await apiRequest("POST", apiPath("/modules/" + module + "/push/" + buildId), {});
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await loadBuilds(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        const target = data.target ? " to " + data.target : "";
        setActivity("Push complete" + target + ".");
      }

      async function syncRemote() {
        const module = state.selectedModule;
        const token = state.selectionToken;
        if (!module) {
          return;
        }
        setActivity("Syncing remote for " + module + "...");
        await apiRequest("POST", apiPath("/remote/sync"), { module: module });
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        await loadBuilds(token, module);
        if (!isSelectionCurrent(token, module)) {
          return;
        }
        setActivity("Remote sync complete.");
      }

      function wireEvents() {
        ui.loadModules.addEventListener("click", () => loadModules().catch(handleError));
        if (ui.viewModules) {
          ui.viewModules.addEventListener("click", () => setView("modules"));
        }
        if (ui.viewPlugins) {
          ui.viewPlugins.addEventListener("click", () => setView("plugins"));
        }
        if (ui.refreshGlobalPlugins) {
          ui.refreshGlobalPlugins.addEventListener("click", () => loadGlobalPlugins().catch(handleError));
        }
        if (ui.loadCustomPlugins) {
          ui.loadCustomPlugins.addEventListener("click", () => loadCustomPlugins().catch(handleError));
        }
        if (ui.pluginModule) {
          ui.pluginModule.addEventListener("change", () => {
            const module = ui.pluginModule.value;
            state.pluginModule = module;
            state.pluginBuild = "";
            const message = module
              ? (isLocalMode ? "Press Load to view custom plugins." : "Select a build to load custom plugins.")
              : "Select a module to load custom plugins.";
            setPluginRowsMessage(ui.customPluginRows, message);
            if (module && module !== state.selectedModule) {
              selectModule(module)
                .then(() => {
                  if (state.view === "plugins") {
                    autoLoadCustomPlugins();
                  }
                })
                .catch(handleError);
              return;
            }
            if (state.view === "plugins") {
              autoLoadCustomPlugins();
            }
          });
        }
        if (ui.pluginBuild) {
          ui.pluginBuild.addEventListener("change", () => {
            state.pluginBuild = ui.pluginBuild.value;
            setPluginRowsMessage(ui.customPluginRows, "Press Load to view custom plugins.");
            if (state.view === "plugins") {
              autoLoadCustomPlugins();
            }
          });
        }
        ui.refreshStatus.addEventListener("click", () => {
          const module = state.selectedModule;
          const token = state.selectionToken;
          refreshStatus(token, module).catch(handleError);
        });
        ui.clearSecret.addEventListener("click", () => {
          localStorage.removeItem(storageKeys.secret);
          ui.secret.value = "";
          if (ui.apiVersion) {
            ui.apiVersion.textContent = "-";
          }
          setActivity("Secret cleared.");
        });
        ui.secret.addEventListener("input", () => {
          localStorage.setItem(storageKeys.secret, ui.secret.value);
          refreshServerStatus().catch(() => {});
        });
        ui.rollbackModule.addEventListener("click", () => rollbackModule().catch(handleError));
        if (ui.buildModule) {
          ui.buildModule.addEventListener("click", () => buildLocalModule().catch(handleError));
        }
        if (ui.syncRemote) {
          ui.syncRemote.addEventListener("click", () => syncRemote().catch(handleError));
        }

        if (ui.menuToggle) {
          ui.menuToggle.addEventListener("click", toggleMenu);
        }
        if (ui.menuPanel) {
          ui.menuPanel.addEventListener("click", (event) => event.stopPropagation());
        }
        if (ui.killAll) {
          ui.killAll.addEventListener("click", () => {
            closeMenu();
            if (!confirm("Kill all hyperbricks processes (except deploy API)?")) {
              return;
            }
            apiRequest("POST", apiPath("/admin/kill-all"))
              .then((data) => {
                const killed = data.killed || [];
                const skipped = data.skipped || [];
                const failed = data.failed || [];
                if (failed.length) {
                  setActivity("Kill all completed with errors: " + failed.join(", "), true);
                  return;
                }
                setActivity("Killed " + killed.length + " process(es). Skipped " + skipped.length + ".");
              })
              .catch(handleError);
          });
        }
        document.addEventListener("click", () => {
          closeMenu();
          closeRowMenus();
        });
        window.addEventListener("resize", closeRowMenus);
        window.addEventListener("scroll", closeRowMenus, true);
      }

      function handleError(err) {
        setActivity(err.message || String(err), true);
      }

      function initDefaults() {
        if (window.location.origin && window.location.origin !== "null") {
          ui.baseUrl.value = window.location.origin;
        }
        const savedSecret = localStorage.getItem(storageKeys.secret);
        if (savedSecret) {
          ui.secret.value = savedSecret;
        }
        const savedView = localStorage.getItem(storageKeys.view);
        if (savedView === "plugins" || savedView === "modules") {
          state.view = savedView;
        }
        updateSignerMode();
        applyModeLabels();
        setView(state.view);
        updateRollbackTarget();
        startServerStatusTick();
        if (isLocalMode) {
          loadModules().catch(handleError);
          refreshServerStatus().catch(handleError);
        } else if (savedSecret) {
          loadModules().catch(handleError);
          refreshServerStatus().catch(handleError);
        }
      }

      wireEvents();
      initDefaults();
    </script>
    <script>
      (function () {
        const storageKey = "hb-theme";
        const themeToggle = document.getElementById("themeToggle");
        const logos = document.querySelectorAll(".hero-logo[data-logo-light]");
        const media = window.matchMedia ? window.matchMedia("(prefers-color-scheme: light)") : null;

        function readStoredTheme() {
          try {
            return localStorage.getItem(storageKey);
          } catch (e) {
            return null;
          }
        }

        function storeTheme(theme) {
          try {
            localStorage.setItem(storageKey, theme);
          } catch (e) {}
        }

        function applyTheme(theme) {
          document.documentElement.setAttribute("data-theme", theme);
          if (themeToggle) {
            const isDark = theme === "dark";
            themeToggle.setAttribute("aria-pressed", isDark ? "true" : "false");
            themeToggle.setAttribute("aria-label", isDark ? "Switch to light theme" : "Switch to dark theme");
            const darkIcon = themeToggle.querySelector(".theme-icon-dark");
            const lightIcon = themeToggle.querySelector(".theme-icon-light");
            if (darkIcon && lightIcon) {
              darkIcon.classList.toggle("hidden", isDark);
              lightIcon.classList.toggle("hidden", !isDark);
            }
          }
          logos.forEach((logo) => {
            const next = theme === "light" ? logo.dataset.logoLight : logo.dataset.logoDark;
            if (next) {
              logo.src = next;
            }
          });
        }

        const storedTheme = readStoredTheme();
        const systemTheme = media && media.matches ? "light" : "dark";
        const initialTheme = storedTheme || systemTheme;
        applyTheme(initialTheme);

        if (themeToggle) {
          themeToggle.addEventListener("click", () => {
            const current = document.documentElement.getAttribute("data-theme") || "dark";
            const next = current === "dark" ? "light" : "dark";
            storeTheme(next);
            applyTheme(next);
          });
        }

        if (media) {
          media.addEventListener("change", (event) => {
            if (readStoredTheme()) {
              return;
            }
            applyTheme(event.matches ? "light" : "dark");
          });
        }
      })();
    </script>
  </body>
</html>
